<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>Sudoku</title>
<link rel="icon" href="image/Sudoku.png">
<style>
body {
  font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
  background: radial-gradient(circle at top left, #380098, black);
  background-size: 200% 200%;
  animation: gradientMove 10s infinite alternate;
  color: #fff;
  margin: 0;
  padding: 0;
  overflow-x: hidden;
  text-align: center;
}

@keyframes gradientMove {
  0% { background-position: 0% 50%; }
  100% { background-position: 100% 50%; }
}

header {
  background: linear-gradient(90deg, #8a2be2, #4b0082);
  color: white;
  padding: 30px 20px;
  font-size: 36px;
  font-weight: bold;
  text-align: center;
  letter-spacing: 1px;
  text-shadow: 0 0 5px #fff, 0 0 10px #8a2be2, 0 0 20px #4b0082, 0 0 30px #8a2be2;
  animation: neon-flicker 2s infinite alternate;
  position: relative;
  z-index: 10;
}

@keyframes neon-flicker {
  0%, 19%, 21%, 23%, 25%, 54%, 56%, 100% {
    text-shadow: 0 0 5px #fff, 0 0 10px #8a2be2, 0 0 20px #4b0082, 0 0 30px #8a2be2;
  }
  20%, 24%, 55% {
    text-shadow: 0 0 2px #fff, 0 0 5px #8a2be2, 0 0 10px #4b0082, 0 0 15px #8a2be2;
  }
}

#sudoku-container {
  display: flex;
  flex-direction: column;
  align-items: center;
  margin: 20px 10px;
  gap: 15px;
}

table {
  border-collapse: collapse;
}

td {
  width: 50px;
  height: 50px;
  border: 1px solid #fff;
  position: relative;
}

td input {
  width: 100%;
  height: 100%;
  font-size: 24px;
  text-align: center;
  border: none;
  outline: none;
  background: rgba(255,255,255,0.8);
  color: #000;
  -moz-appearance: textfield;
}

td input::-webkit-outer-spin-button,
td input::-webkit-inner-spin-button {
  -webkit-appearance: none;
  margin: 0;
}

td.given input {
  background: rgba(0,0,0,0.5);
  color: #fff;
  font-weight: bold;
}

td.wrong input {
  background: #ff0000;
  color: #fff;
}

.controls {
  display: flex;
  gap: 10px;
  flex-wrap: wrap;
  justify-content: center;
  margin-bottom: 20px;
}

button, select {
  padding: 10px 20px;
  font-size: 16px;
  border-radius: 8px;
  border: none;
  cursor: pointer;
  font-weight: bold;
}

button:hover, select:hover {
  transform: scale(1.05);
}

button#back { background: #8a2be2; color: #fff; }
button#reset { background: #4b0082; color: #fff; }
button#newgame { background: #6a0dad; color: #fff; }
button#surrender { background: #ff0000; color: #fff; }

select { background: #1c1c2c; color: #fff; }

#starsCanvas, #rippleCanvas {
  position: fixed;
  top:0; left:0;
  width:100vw; height:100vh;
  pointer-events:none;
}
#starsCanvas{z-index:0;} 
#rippleCanvas{z-index:0;}
</style>
</head>
<body>

<canvas id="starsCanvas"></canvas>
<canvas id="rippleCanvas"></canvas>

<header>Sudoku</header>

<div id="sudoku-container">
  <div class="controls">
    <select id="difficulty">
      <option value="easy">Easy</option>
      <option value="medium">Medium</option>
      <option value="hard">Hard</option>
    </select>
    <button id="newgame">New Game</button>
    <button id="reset">Reset</button>
    <button id="surrender">Surrender</button>
    <button id="back" onclick="goBack()">Back to Lobby</button>
  </div>
  <table id="sudoku-grid"></table>
</div>

<script>
function goBack(){ window.location.href="index.html"; }

/* ===== Sudoku Logic ===== */
let sudokuGrid = document.getElementById("sudoku-grid");
let currentPuzzle = [];
let solution = [];

// Example puzzles per difficulty
const puzzles = {
  easy: [
    [[5,3,0,0,7,0,0,0,0],[6,0,0,1,9,5,0,0,0],[0,9,8,0,0,0,0,6,0],[8,0,0,0,6,0,0,0,3],[4,0,0,8,0,3,0,0,1],[7,0,0,0,2,0,0,0,6],[0,6,0,0,0,0,2,8,0],[0,0,0,4,1,9,0,0,5],[0,0,0,0,8,0,0,7,9]]
  ],
  medium: [
    [[0,0,0,2,6,0,7,0,1],[6,8,0,0,7,0,0,9,0],[1,9,0,0,0,4,5,0,0],[8,2,0,1,0,0,0,4,0],[0,0,4,6,0,2,9,0,0],[0,5,0,0,0,3,0,2,8],[0,0,9,3,0,0,0,7,4],[0,4,0,0,5,0,0,3,6],[7,0,3,0,1,8,0,0,0]]
  ],
  hard: [
    [[0,0,0,6,0,0,4,0,0],[7,0,0,0,0,3,6,0,0],[0,0,0,0,9,1,0,8,0],[0,0,0,0,0,0,0,0,0],[0,5,0,1,8,0,0,0,3],[0,0,0,3,0,6,0,4,5],[0,4,0,2,0,0,0,6,0],[9,0,3,0,0,0,0,0,0],[0,2,0,0,0,0,1,0,0]]
  ]
};

// Function to deep copy 2D array
function copy2D(arr){
  return arr.map(r => r.slice());
}

// Simple solver to store solution
function solve(grid){
  let g = copy2D(grid);
  function isSafe(r,c,n){
    for(let i=0;i<9;i++){
      if(g[r][i]===n || g[i][c]===n) return false;
    }
    let sr = Math.floor(r/3)*3, sc=Math.floor(c/3)*3;
    for(let i=0;i<3;i++){
      for(let j=0;j<3;j++){
        if(g[sr+i][sc+j]===n) return false;
      }
    }
    return true;
  }
  function backtrack(){
    for(let r=0;r<9;r++){
      for(let c=0;c<9;c++){
        if(g[r][c]===0){
          for(let n=1;n<=9;n++){
            if(isSafe(r,c,n)){
              g[r][c]=n;
              if(backtrack()) return true;
              g[r][c]=0;
            }
          }
          return false;
        }
      }
    }
    return true;
  }
  backtrack();
  return g;
}

function generatePuzzle(level){
  let puzzleList = puzzles[level];
  let idx = Math.floor(Math.random()*puzzleList.length);
  currentPuzzle = copy2D(puzzleList[idx]);
  solution = solve(copy2D(currentPuzzle));
  renderGrid();
}

function renderGrid(){
  sudokuGrid.innerHTML="";
  for(let i=0;i<9;i++){
    let row = sudokuGrid.insertRow();
    for(let j=0;j<9;j++){
      let cell = row.insertCell();
      let input = document.createElement("input");
      input.type="number"; input.min=1; input.max=9;
      input.value = currentPuzzle[i][j]!==0 ? currentPuzzle[i][j] : "";
      if(currentPuzzle[i][j]!==0){
        input.disabled=true;
        cell.classList.add("given");
      } else {
        input.addEventListener("input", ()=>{cell.classList.remove("wrong")});
      }
      cell.appendChild(input);
      if(j%3===2) cell.style.borderRight="3px solid #fff";
      if(i%3===2) cell.style.borderBottom="3px solid #fff";
    }
  }
}

function resetGrid(){
  let inputs = sudokuGrid.getElementsByTagName("input");
  for(let i=0;i<9;i++){
    for(let j=0;j<9;j++){
      let idx = i*9+j;
      if(!inputs[idx].disabled){
        inputs[idx].value="";
        inputs[idx].parentElement.classList.remove("wrong");
      }
    }
  }
}

function surrenderGrid(){
  let inputs = sudokuGrid.getElementsByTagName("input");
  for(let i=0;i<9;i++){
    for(let j=0;j<9;j++){
      let idx = i*9+j;
      if(inputs[idx].value==="" || parseInt(inputs[idx].value)!==solution[i][j]){
        inputs[idx].value = solution[i][j];
        inputs[idx].parentElement.classList.add("wrong");
      }
    }
  }
}

// Buttons
document.getElementById("newgame").onclick = ()=>{generatePuzzle(document.getElementById("difficulty").value)};
document.getElementById("reset").onclick = resetGrid;
document.getElementById("surrender").onclick = surrenderGrid;

// Init default
generatePuzzle("easy");

/* ===== Stars + Meteor ===== */
const starsCanvas = document.getElementById('starsCanvas');
const starsCtx = starsCanvas.getContext('2d');
let stars = [], meteor=null;
function resizeStarsCanvas(){
  starsCanvas.width=window.innerWidth;
  starsCanvas.height=window.innerHeight;
  generateStars();
}
function generateStars(){
  stars=[];
  for(let i=0;i<200;i++){
    stars.push({x:Math.random()*starsCanvas.width,y:Math.random()*starsCanvas.height,alpha:Math.random()*0.7+0.3,radius:Math.random()*1.5+0.5,flickerSpeed:Math.random()*0.05+0.02});
  }
}
function drawMeteor(){
  if(!meteor) return;
  starsCtx.save();
  const grad=starsCtx.createLinearGradient(meteor.x,meteor.y,meteor.x-meteor.vx*10,meteor.y-meteor.vy*10);
  grad.addColorStop(0,`rgba(255,255,255,${meteor.alpha})`);
  grad.addColorStop(1,`rgba(255,255,255,0)`);
  starsCtx.strokeStyle=grad;
  starsCtx.lineWidth=2;
  starsCtx.beginPath();
  starsCtx.moveTo(meteor.x,meteor.y);
  starsCtx.lineTo(meteor.x-meteor.vx*20,meteor.y-meteor.vy*20);
  starsCtx.stroke();
  starsCtx.restore();
}
function animateStars(){
  starsCtx.clearRect(0,0,starsCanvas.width,starsCanvas.height);
  stars.forEach(star=>{
    star.alpha+=star.flickerSpeed*(Math.random()<0.5?-1:1);
    if(star.alpha<0.1) star.alpha=0.1;
    if(star.alpha>1) star.alpha=1;
    starsCtx.beginPath();
    starsCtx.arc(star.x,star.y,star.radius,0,Math.PI*2);
    starsCtx.fillStyle=`rgba(255,255,255,${star.alpha})`;
    starsCtx.fill();
  });
  if(meteor){
    meteor.x+=meteor.vx;
    meteor.y+=meteor.vy;
    meteor.alpha-=0.01;
    drawMeteor();
    if(meteor.alpha<=0||meteor.x<-50||meteor.y>starsCanvas.height+50){meteor=null;setTimeout(spawnMeteor,Math.random()*5000+3000);}
  }
  requestAnimationFrame(animateStars);
}
function spawnMeteor(){meteor={x:Math.random()*starsCanvas.width,y:-20,vx:-(Math.random()*4+2),vy:Math.random()*2+2,alpha:1};}
window.addEventListener('resize',resizeStarsCanvas);
resizeStarsCanvas();animateStars();setTimeout(spawnMeteor,3000);

/* ===== Ripple Effect ===== */
const rippleCanvas=document.getElementById('rippleCanvas');
const rippleCtx=rippleCanvas.getContext('2d');
let ripples=[];
function resizeRippleCanvas(){rippleCanvas.width=window.innerWidth;rippleCanvas.height=window.innerHeight;}
window.addEventListener('resize',resizeRippleCanvas);resizeRippleCanvas();
window.addEventListener('mousemove',(e)=>{ripples.push({x:e.clientX,y:e.clientY,radius:0,alpha:0.3,lineWidth:1+Math.random()});if(ripples.length>20) ripples.shift();});
function animateRipples(){rippleCtx.clearRect(0,0,rippleCanvas.width,rippleCanvas.height);ripples.forEach((r,i)=>{r.radius+=1.5;r.alpha-=0.007;if(r.alpha<=0){ripples.splice(i,1);return;}rippleCtx.beginPath();rippleCtx.arc(r.x,r.y,r.radius,0,Math.PI*2);rippleCtx.strokeStyle=`rgba(56,0,152,${r.alpha})`;rippleCtx.lineWidth=r.lineWidth;rippleCtx.stroke();});requestAnimationFrame(animateRipples);}
animateRipples();
</script>
</body>
</html>
